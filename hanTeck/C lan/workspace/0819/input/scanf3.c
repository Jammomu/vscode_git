#include <stdio.h>
/* 
  문자열
	 1) 문자가 나열되어 있다.
	 2) 문자열은 메모리 크기가 정해져 있지 않다.
	 3) 문자열을 만들면 자동으로 문자열의 주소가 만들어 진다.
	 4) 문자열변수(배열) 앞에는 &을 붙이지 않는다(주소가 이미 만들어지기 떄문에)
	 5) 문자열은 배열이나 포이터로 값을 저장한다.
	 6) ★ 문자열은 참조형 이다!!!

	 문자열 변수
	   **문자(char) 나열 -> 줄지어 만들자 -> char을 여러개 줄지어 메모리공간을 만들수 있다. : 배열!!!!
	   **문자열은 이미 주소를 갖고 있다. -> 포인터로 만들 수 있다.

	   1) 포인터로 입력받기
	       char * 변수명;
		   char *nara;
		   char *country;    country 라는 변수명은 이미 주소가 있기 떄문에 &를 붙이지 않는다.
		                     scanf("%s", country); <----- &를 붙이지 않는다.

	   2) 배열로 만들기
	       char nara[10]; char 1byte 짜리 메모리 공간을 10개 줄지어 만들어라!!!!

	 문자열 입력받기
*/
void main()
{
	printf("%s : %d번지\n", "korea", "korea"); //문자열은 %s로 출력하는건데....
											  //두번쨰 변수는 %d로 출력하고 있네???? --> 주소출력
											  //문자열에서는 &를 붙이지 않는다.

	//자료형, 문자열, 변수의 메모리 크기를 조사해 보자: sizeof() 연산자
	//sizeof(??)  ?? : 소괄호 안에, 문자열, 변수, 자료형, 배열 등을 넣으면
	//                  메모리(byte 수) 를 알려준다.


	printf("korea의 바이트수: %dbyte\n",sizeof("korea")); //5바이트 가 아니라 6바이트가 된다.
	printf("int의 바이트수: %dbyte\n",sizeof(int)); // 문자열 종료 널문자 숨어있다.
	printf("float의 바이트수: %dbyte\n",sizeof(float));
	printf("double의 바이트수: %dbyte\n",sizeof(double));
	printf("1.1f의 형변환 바이트수: %dbyte\n",sizeof((double)1.1f)); // 형변환 -> ()안에 있는 타입으로 바꿔줘!!!
	printf("1.1의 형변환 바이트수: %dbyte\n",sizeof((int)1.1)); //1.1을 (int) 형으로 변경해줘
	// %s 시작위치에서 널까지만 출력할 것
	printf("%s\n", "kor\0ea"); //kor 까지만 나온다.

	// 시작 위치 변경 : 주소에다가 +1 +2 등, 연산을 하면 시작위치를 변경해서 출력할수 있다.
	printf("%s+0\n", "korea"+0);  //처음자리에서 출력
	printf("%s+1\n", "korea"+1);  //처음자리에서 1칸이동후 출력
	printf("%s+2\n", "korea"+2);  //처음자리에서 2칸이동후 출력
	printf("%s+3\n", "korea"+3);  //처음자리에서 3칸이동후 출력
	printf("%s+4\n", "korea"+4);  //처음자리에서 4칸이동후 출력
}